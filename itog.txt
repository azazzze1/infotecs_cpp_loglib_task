file(GLOB LOGGER_HEADERS "*.hpp" "*.h")
file(GLOB LOGGER_SOURCES "*.cpp")

if(BUILD_SHARED_LIB)
    add_library(logger SHARED ${LOGGER_SOURCES})
else()
    add_library(logger STATIC ${LOGGER_SOURCES})
endif()

target_include_directories(logger PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# export(TARGETS logger FILE logger-config.cmake)
#ifndef ILOGGER_HPP
#define ILOGGER_HPP

#include <string>
#include <memory>


/**
* @brief Уровни логирования для классификации сообщений.
*/
enum class LogLevel {
    INFO, ///< Сообщения, носящие информационный характер 
    WARNING, ///< Сообщения, указывающие на возможную ошибку
    ERROR  ///< Сообщения, указывающие на произошедщую ошибку
};

/** 
* @class ILogger
* @brief Интерфейс для систем логирования.
*
* Предоставляет унифицированный способ записи логов, а также возможность изменять
* уровень логирования по умолчанию. 
*/
class ILogger{
    public:
        /**
        * @brief Виртуальный деструктор по умолчанию. 
        */
        virtual ~ILogger() = default;

        /** 
        * @brief Запись сообщения в лог с указанным уровнем важности.
        * @param message Текст сообщения.
        * @param logLevel Уровень важности.
        */
        virtual void log(const std::string& message, LogLevel logLevel) = 0; 

        /**
        * @brief Запись сообщения в лог без указания уровня важности. 
        * @param message Текст сообщения.
        *
        * Уровень важности по умолчанию зависит от реализации метода. 
        */
        virtual void log(const std::string& message) = 0; 

        /**
        * @brief Изменение уровня важности по умолчанию.  
        * @param logLevel Уровень важности. 
        */
        virtual void setLogLevel(LogLevel logLevel) = 0;
};

#endif 
#include "logger.hpp"

// Реализация FileLogger 

FileLogger::FileLogger(const std::string& filename, LogLevel defaultLevel) : defaultLevel(defaultLevel) {
    file_.open(filename, std::ios::app);

    if (!file_) std::cerr<<"Ошибка при открытии следующего файла: "<<filename<<std::endl;  
}

FileLogger::~FileLogger(){
    if (file_.is_open()) file_.close();
}

void FileLogger::log(const std::string& message, LogLevel logLevel){
    if(logLevel < defaultLevel) return; 
    std::lock_guard<std::mutex> lock(mtx_); 
    if(!file_.is_open()) return;
    file_<<"["<<LoggerUtils::currentTime()<<"] ["<<LoggerUtils::levelToString(logLevel)<<"] "<<message<<std::endl;
}

void FileLogger::log(const std::string& message){
    log(message, defaultLevel); 
}

void FileLogger::setLogLevel(LogLevel logLevel){
    defaultLevel = logLevel;
}

// Реализация SocketLogger 

SocketLogger::SocketLogger(const std::string& host, int port, LogLevel defaultLevel) : defaultLevel(defaultLevel) {
    defaultLevel = defaultLevel;
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0){
        std::cerr<<"Ошибка при создании сокета"<<std::endl;
        return;
    }

    sockaddr_in serv_address{};
    serv_address.sin_family = AF_INET;
    serv_address.sin_port = htons(port);

    if (inet_pton(AF_INET, host.c_str(), &serv_address.sin_addr) <= 0){
        std::cerr<<"Некорректный адрес"<<std::endl;
        close(sockfd);
        sockfd = -1;
        return;
    }

    if (connect(sockfd, (struct sockaddr *)&serv_address, sizeof(serv_address)) < 0){
        std::cerr<<"Ошибка при подключении к сокету"<<std::endl;
        close(sockfd);
        sockfd = -1; 
    }
}

SocketLogger::~SocketLogger(){
    if (sockfd > -1) close(sockfd); 
}

void SocketLogger::log(const std::string& message, LogLevel logLevel) {
    if(logLevel < defaultLevel) return; 

    std::lock_guard<std::mutex> lock(mtx_); 
    
    if (sockfd <= -1) return;

    std::string logMessage = "["+LoggerUtils::currentTime()+"] ["+LoggerUtils::levelToString(logLevel)+"] "+message+"\n";

    send(sockfd, logMessage.c_str(), logMessage.size(), 0); 
}

void SocketLogger::setLogLevel(LogLevel logLevel){
    defaultLevel = logLevel;
}

void SocketLogger::log(const std::string& message){
    log(message, defaultLevel); 
}
#include "loggerFactory.hpp"

// Реализация LoggerFactory

std::unique_ptr<ILogger> LoggerFactory::createFileLogger(const std::string& filename, LogLevel defaultLevel) {
    return std::make_unique<FileLogger>(filename, defaultLevel);
}

std::unique_ptr<ILogger> LoggerFactory::createSocketLogger(const std::string& host, int port, LogLevel defaultLevel) {
    return std::make_unique<SocketLogger>(host, port, defaultLevel);
}
#ifndef LOGGER_FACTORY_HPP
#define LOGGER_FACTORY_HPP

#include "ilogger.hpp"
#include "logger.hpp"
#include <memory>

/**
 * @class LoggerFactory 
 * @brief Паттерн проектирования "Factory" для создания объектов-логгеров.
 *   
 * Позволяет создавать разные типы логгеров через статические методы. 
 */
class LoggerFactory {
    public:
        /**
         * @brief Конструктор с запретом создания объектов класса. 
         */
        LoggerFactory() = delete;
        
        /**
         * @brief Создание объекта-логера типа FileLogger. 
         * 
         * @param filename Относительный путь файла. 
         * @param defaultLevel Уровень важности по умолчанию. 
         * @return std::unique_ptr<ILogger> Умный указатель на созданный логгер. 
         */
        static std::unique_ptr<ILogger> createFileLogger(
            const std::string& filename, 
            LogLevel defaultLevel = LogLevel::INFO);
        
        /**
         * @brief Создание объекта-логера типа SocketLogger. 
         * 
         * @param host IP-адрес сокета для подключения.
         * @param port PORT сокета для подключения. 
         * @param defaultLevel Уровень логирования по умолчанию. 
         * @return std::unique_ptr<ILogger> Умный указатель на созданный логгер. 
         */
        static std::unique_ptr<ILogger> createSocketLogger(
            const std::string& host, int port, 
            LogLevel defaultLevel = LogLevel::INFO);
    };

#endif
#ifndef LOGGER_HPP
#define LOGGER_HPP

#include "ilogger.hpp"
#include "loggerUtils.hpp"
#include <string>
#include <fstream>
#include <iostream> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <mutex>


/**
 * @class FileLogger
 * @brief Реализация ILogger, записывающая логи в файл.
 *
 * Пример формата записи лога: 
 * [Fri Jul 18 13:29:55 2025] [INFO] Text for test?
 */
class FileLogger : public ILogger{
public:
    /**
     * @brief Конструктор с подключением к файлу логирования. 
     * 
     * @param filename Относительный путь к файлу записи. 
     * @param defaultLevel Уровень важности по умолчанию. 
     *
     * Если файла не существует, то создаётся новый.  
     */
    FileLogger(const std::string& filename, LogLevel defaultLevel);

    /**
     * @brief Деструктор. Закрывает файл при уничтожении объекта. 
     */
    ~FileLogger() override; 

    /** 
    * @brief Логирование в файл с указанным уровнем важности.
    * @param message Текст сообщения.
    * @param logLevel Уровень важности.
    */
    void log(const std::string& message, LogLevel logLevel) override;

    /**
    * @brief Логирование в файл c уровнем важности defaultLevel. 
    * @param message Текст сообщения.
    */
    void log(const std::string& message) override; 

    /**
    * @brief Изменение уровня важности по умолчанию.  
    * @param logLevel Уровень важности. 
    */
    void setLogLevel(LogLevel logLevel) override; 

private:
    LogLevel defaultLevel; ///< Уровень логирования по умолчанию. 
    std::ofstream file_; ///< Поток файла для записи логов. 
    std::mutex mtx_; ///< Защита доступа к файлу при многопоточности. 
};

/**
 * @class SocketLogger
 * @brief Реализация ILogger, отправляющая логи в сокет.
 *
 * Формат записи лога: 
 * [Fri Jul 18 13:29:55 2025] [INFO] Text for test? 
 */
class SocketLogger : public ILogger{
public:
    /**
     * @brief Конструктор с подключением к сокету.
     * 
     * @param host IP-адрес сокета для подключения.
     * @param port PORT сокета для подключения. 
     * @param defaultLevel Уровень логирования по умолчанию. 
     */
    SocketLogger(const std::string& host, int port, LogLevel defaultLevel);

    /**
     * @brief Деструктор. Завершает соединение с сокетом. 
     */
    ~SocketLogger() override; 

    /** 
    * @brief Отправка лога в сокет с указанным уровнем важности.
    * @param message Текст сообщения.
    * @param logLevel Уровень важности.
    */
    void log(const std::string& message, LogLevel logLevel) override;

    /**
    * @brief Отправка лога в сокет c уровнем важности defaultLevel. 
    * @param message Текст сообщения.
    */
    void log(const std::string& message) override; 

    /**
    * @brief Изменение уровня важности по умолчанию.  
    * @param logLevel Уровень важности. 
    */
    void setLogLevel(LogLevel logLevel) override; 

private:
    int sockfd; ///< Дескриптор сокета для поддержки соединения.
    LogLevel defaultLevel; ///< Уровень важности по умолчанию.
    std::mutex mtx_;  ///< Защита доступа к сокету при многопоточности.
};

#endif 
#include "loggerUtils.hpp"

// Реализация LoggerUtils 

std::optional<LogLevel> LoggerUtils::stringToLevel(const std::string& stringLevel){
    if (stringLevel == "INFO")  return LogLevel::INFO;
    else if (stringLevel == "WARNING") return LogLevel::WARNING;
    else if (stringLevel == "ERROR") return LogLevel::ERROR;
    
    return std::nullopt;
}

std::string LoggerUtils::levelToString(LogLevel logLevel){
    switch(logLevel){
        case LogLevel::INFO : return "INFO";
        case LogLevel::WARNING : return "WARNING";
        case LogLevel::ERROR : return "ERROR";
        default : return "UNKNOWN";
    }
}

std::string LoggerUtils::currentTime(){
    auto time = std::chrono::system_clock::now();
    std::time_t tTime = std::chrono::system_clock::to_time_t(time);
    std::string fullDate = std::ctime(&tTime);
    if(!fullDate.empty()) fullDate.pop_back();
    return fullDate;              
}

bool LoggerUtils::validateLogLevel(std::optional<LogLevel> optLevel, LogLevel& outLogLevelValue){
    if (!optLevel) {
        return false;
    }
    outLogLevelValue = optLevel.value();
    return true; 
}
#ifndef LOGGER_UTILS_HPP
#define LOGGER_UTILS_HPP

#include "ilogger.hpp"
#include <string>
#include <ctime>
#include <chrono>
#include <optional>
#include <iostream>

/**
 * @class LoggerUtils
 * @brief Инструменты, используемые при логировании файлов.
 */
class LoggerUtils{
public:
    /**
     * @brief Конвертация объекта LogLevel в std::string. 
     * 
     * @param logLevel Уровень важности для конвертации. 
     * @return std::string Возвращает строку для вывода в лог. 
     */
    static std::string levelToString(LogLevel logLevel);

    /**
     * @brief Конвертация std::string в объект LogLevel.
     * 
     * @param stringLevel Строка для конвертации. 
     * @return std::optional<LogLevel> Возвращает уровень важности.
     * Если строка не содержит уровень важности, возвращается нулевой указатель в std::optional. 
     */
    static std::optional<LogLevel> stringToLevel(const std::string& stringLevel);

    /**
     * @brief Определение времени создания лога. 
     * 
     * @return std::string Возвращает строку для вывода в лог.
     * Формат даты логирования: Fri Jul 18 13:29:55 2025
     */
    static std::string currentTime();

    /**
     * @brief Проверка: имеется ли в std::optional значение уровня важности. 
     * 
     * @param optLevel Тип std::optional с уровнем важности или нулевым указателем. 
     * @param outLogLevelValue Если уровень важности есть, то он определяется в данную переменную.
     * @return true Уровень важности найден и передан в outLogLevelValue.
     * @return false optLevel содержит нулевой указатель. 
     */
    static bool validateLogLevel(std::optional<LogLevel> optLevel, LogLevel& outLogLevelValue);
};

#endif
